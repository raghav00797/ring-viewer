<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Ring Viewer</title>
  <style>
    html, body { margin: 0; height: 100%; background: #0b0b0b; overflow: hidden; }
    #wrap { position: fixed; inset: 0; }
    canvas { width: 100%; height: 100%; display: block; touch-action: none; }
    .ui {
      position: fixed; left: 12px; bottom: 12px; display: flex; gap: 10px;
      font-family: Arial, sans-serif; z-index: 10;
    }
    .btn {
      background: rgba(255,255,255,0.12);
      border: 1px solid rgba(255,255,255,0.18);
      color: white;
      padding: 10px 12px;
      border-radius: 12px;
      cursor: pointer;
      user-select: none;
      backdrop-filter: blur(10px);
    }
    .btn:active { transform: scale(0.98); }
    .hint {
      position: fixed; right: 12px; top: 12px;
      color: rgba(255,255,255,0.7);
      font-family: Arial, sans-serif;
      font-size: 13px;
      z-index: 10;
      background: rgba(0,0,0,0.35);
      padding: 8px 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.12);
    }
  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="c"></canvas>
  </div>

  <div class="hint">Drag to rotate • Scroll/pinch to zoom</div>
  <div class="ui">
    <div class="btn" id="btnAuto">Auto: ON</div>
    <div class="btn" id="btnReset">Reset</div>
  </div>

  <script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.module.js";
    import { GLTFLoader } from "https://cdn.jsdelivr.net/npm/three@0.159.0/examples/jsm/loaders/GLTFLoader.js";

    // ✅ Your Google Drive File ID
    const DRIVE_FILE_ID = "1xQaoIODOj3p1vJjOzdoQf9qt9KaP9XuK";

    // ✅ Direct download URL for Three.js loader
    const GLB_URL = `https://drive.google.com/uc?export=download&id=${DRIVE_FILE_ID}`;

    const canvas = document.getElementById("c");
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.outputColorSpace = THREE.SRGBColorSpace;

    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(35, 1, 0.01, 100);
    camera.position.set(0, 0.15, 2.2);

    // Lights
    const hemi = new THREE.HemisphereLight(0xffffff, 0x111111, 1.1);
    scene.add(hemi);

    const key = new THREE.DirectionalLight(0xffffff, 1.2);
    key.position.set(2, 3, 2);
    scene.add(key);

    const fill = new THREE.DirectionalLight(0xffffff, 0.6);
    fill.position.set(-2, 1, 2);
    scene.add(fill);

    // Group to rotate ring
    const ringGroup = new THREE.Group();
    scene.add(ringGroup);

    let ringObject = null;

    // Load GLB
    const loader = new GLTFLoader();
    loader.load(
      GLB_URL,
      (gltf) => {
        ringObject = gltf.scene;
        ringGroup.add(ringObject);

        // Auto-center and scale
        const box = new THREE.Box3().setFromObject(ringObject);
        const size = new THREE.Vector3();
        const center = new THREE.Vector3();
        box.getSize(size);
        box.getCenter(center);

        ringObject.position.sub(center);

        const maxDim = Math.max(size.x, size.y, size.z);
        const scale = 1.0 / maxDim;
        ringObject.scale.setScalar(scale * 1.1);

        // Start nice angle
        ringGroup.rotation.set(0.15, 0.8, 0);
      },
      undefined,
      (err) => {
        console.error("GLB load error:", err);
        alert("Failed to load GLB from Google Drive. Check link permission / file id.");
      }
    );

    // Resize
    function resize() {
      const w = window.innerWidth;
      const h = window.innerHeight;
      renderer.setSize(w, h, false);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
    }
    window.addEventListener("resize", resize);
    resize();

    // ========= Drag rotate + inertia =========
    let isDragging = false;
    let lastX = 0;
    let lastY = 0;

    let velX = 0;
    let velY = 0;

    const dragSpeed = 0.0075;
    const damping = 0.93;

    let autoRotate = true;

    canvas.addEventListener("pointerdown", (e) => {
      isDragging = true;
      canvas.setPointerCapture(e.pointerId);
      lastX = e.clientX;
      lastY = e.clientY;
    });

    canvas.addEventListener("pointermove", (e) => {
      if (!isDragging) return;

      const dx = e.clientX - lastX;
      const dy = e.clientY - lastY;
      lastX = e.clientX;
      lastY = e.clientY;

      velX = dx * dragSpeed;
      velY = dy * dragSpeed;

      ringGroup.rotation.y += velX;
      ringGroup.rotation.x += velY;
    });

    canvas.addEventListener("pointerup", (e) => {
      isDragging = false;
      try { canvas.releasePointerCapture(e.pointerId); } catch {}
    });

    // ========= Zoom (mouse wheel) =========
    window.addEventListener("wheel", (e) => {
      const delta = Math.sign(e.deltaY);
      camera.position.z += delta * 0.12;
      camera.position.z = THREE.MathUtils.clamp(camera.position.z, 1.2, 4.0);
    }, { passive: true });

    // Buttons
    const btnAuto = document.getElementById("btnAuto");
    const btnReset = document.getElementById("btnReset");

    btnAuto.addEventListener("click", () => {
      autoRotate = !autoRotate;
      btnAuto.textContent = autoRotate ? "Auto: ON" : "Auto: OFF";
    });

    btnReset.addEventListener("click", () => {
      ringGroup.rotation.set(0.15, 0.8, 0);
      velX = 0;
      velY = 0;
      camera.position.set(0, 0.15, 2.2);
    });

    // Render loop
    function animate() {
      requestAnimationFrame(animate);

      if (!isDragging) {
        // inertia
        ringGroup.rotation.y += velX;
        ringGroup.rotation.x += velY;
        velX *= damping;
        velY *= damping;

        // auto rotate
        if (autoRotate) ringGroup.rotation.y += 0.003;
      }

      renderer.render(scene, camera);
    }
    animate();
  </script>
</body>
</html>
